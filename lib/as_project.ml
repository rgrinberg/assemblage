(*
 * Copyright (c) 2014 Thomas Gazagnaire <thomas@gazagnaire.org>
 * Copyright (c) 2014 Daniel C. BÃ¼nzli
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

open Astring
open Bos

(* Project *)

type t =
  { name : string;                               (* The name of the project. *)
    exists : bool As_conf.value;              (* [true] if exists in config. *)
    args : As_args.t;            (* argument bundle appended to all actions. *)
    schemes : As_conf.scheme list;    (* user-defined configuration schemes. *)
    parts : As_part.kind As_part.t list;(* project's toplevel parts, unique. *)
    deps : As_conf.Key.Set.t Lazy.t;           (* config key deps (derived). *)
    conf : As_conf.t option; }       (* configuration to use, set by driver. *)

let deps p =
  let add_part acc p = As_conf.Key.Set.union acc (As_part.deps p) in
  let add_key k acc = As_conf.Key.(Set.add (hide_type k) acc) in
  List.fold_left add_part As_conf.Key.Set.empty p.parts
  |> add_key As_conf.project_version
  |> add_key As_conf.root_dir

let v ?(exists = As_conf.true_) ?(args = As_args.empty) ?(schemes = []) name
    ~parts =
  let parts = As_part.list_uniquify (parts :> As_part.kind As_part.t list) in
  let rec p =
    { name; exists; args; schemes; parts; deps = lazy (deps p); conf = None; }
  in
  p

let name p = p.name
let exists p = p.exists
let args p = p.args
let schemes p = p.schemes
let parts p = p.parts
let deps p = Lazy.force p.deps

(* Configuration and evaluation *)

let warn_no_config = format_of_string
    "No@ configuration@ set@ for@ project,@ using@ base@ configuration."

let conf p = match p.conf with
| Some c -> c
| None ->
    As_misc.log_driver_fault Log.Warning warn_no_config;
    As_conf.of_keys (deps p)

let with_conf old c = { old with conf = Some c; }
let eval p v = As_conf.eval (conf p) v
let eval_key p k = eval p (As_conf.value k)

(* Configuration dependent values *)

let version p = eval_key p As_conf.project_version

let products ?(kind = `Any) proj =
  let add_path acc p = Path.Set.add p acc in
  let add_part acc part =
    let add_action (i, o) act =
      List.fold_left add_path i (As_action.inputs act),
      List.fold_left add_path o (As_action.outputs act)
    in
    List.fold_left add_action acc (eval proj (As_part.actions part))
  in
  let init = Path.Set.empty, Path.Set.empty in
  let i, o = As_part.list_fold add_part init (parts proj) in
  match kind with
  | `Any -> Path.Set.union i o
  | `Source -> Path.Set.diff i o
  | `Input -> i
  | `Output -> o

let watermark_string ?suffix p =
  let suffix = match suffix with
  | None -> "-- generated by assemblage %%VERSION%%"
  | Some s -> s
  in
  strf "%s %s %s" (name p) (version p) suffix

let pp_signature ppf p =
  let pp_icon = (* UTF-8 <U+0020, U+1F377> *)
    let pp_icon ppf () = Fmt.pf ppf " \xF0\x9F\x8D\xB7" in
    Fmt.(if_utf_8 pp_icon nop)
  in
  Fmt.(pf ppf "%a %s%a"
         (styled_string `Bold) (name p) (version p) pp_icon ())

(* Assembling projects *)

let projects = ref []
let assemble p = projects := p :: !projects
let list () = List.rev !projects
