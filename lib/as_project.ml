(*
 * Copyright (c) 2014 Thomas Gazagnaire <thomas@gazagnaire.org>
 * Copyright (c) 2014 Daniel C. BÃ¼nzli
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

let str = Printf.sprintf

(* Project *)

type t =
  { name : string;
    cond : bool As_conf.value;
    args : As_args.t;
    parts : As_part.kind As_part.t list;
    actions : As_action.t list;
    default_conf : As_conf.t Lazy.t;
    conf : As_conf.t option; }

let default_conf p = (* TODO *)
  let ( + ) = As_conf.add in
  let open As_conf in
  empty + debug + profile + test + doc + jobs +
  root_dir + build_dir + product_dir
  + ocaml_native_tools + ocaml_byte + ocaml_native +
  ocaml_native_dynlink + ocaml_js + ocaml_annot + warn_error +
  ocaml_build_ast + ocaml_dumpast +
  ocamlc + ocamlopt + js_of_ocaml + ocamldep + ocamlmklib +
  ocamldoc + ocamllex + ocamlyacc + ocaml + ocamlrun + ocamldebug + ocamlprof +
  ocamlfind + ocaml_version + ln + cp + mv + cd + rm + rmdir + mkdir + cat +
  make + cc + host_word_size + target_word_size +
  pkg_config + uname + host_os + host_arch + target_os + target_arch + opam +
  opam_installer + opam_admin + project_version

let v ?(cond = As_conf.true_) ?(args = As_args.empty) ?(actions = [])
    name parts =
  let rec p =
    { name; cond; args;
      parts = (parts :> As_part.kind As_part.t list);
      actions;
      default_conf = lazy (default_conf p);
      conf = None; }
  in
  p

(* Static attributes *)

let name p = p.name
let cond p = p.cond
let args p = p.args
let parts p = p.parts
let actions p = p.actions

(* Configuration *)

let default_conf p = Lazy.force p.default_conf
let conf p = match p.conf with
| Some c -> c
| None ->
    As_log.msg_driver_fault As_log.Warning
      "No@ configuration@ set@ for@ project,@ using@ default@ configuration.";
    default_conf p

let with_conf p c = { p with conf = Some c }
let eval p v = As_conf.eval (conf p) v
let eval_key p k = eval p (As_conf.value k)

(* Configuration dependent values *)

let version p = eval_key p As_conf.project_version
let products ?(root = true) p = As_path.Set.empty (* TODO *)
let watermark_string ?suffix p =
  let suffix = match suffix with
  | None -> "-- generated by assemblage %%VERSION%%"
  | Some s -> s
  in
  str "%s %s %s" (name p) (version p) suffix

let pp_signature ppf p =
  let pp_icon = (* UTF-8 <U+0020, U+1F377> *)
    let pp_icon ppf () = As_fmt.pp ppf " \xF0\x9F\x8D\xB7" in
    As_fmt.(pp_if_utf8 pp_icon nop)
  in
  As_fmt.(pp ppf "%a %s%a"
            (pp_styled_str `Bold) (name p) (version p) pp_icon ())

(* Assembled projects *)

let projects = ref []
let assemble p = projects := p :: !projects
let list () = List.rev !projects
